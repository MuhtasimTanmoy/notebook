# [Linkers and loaders](https://wh0rd.org/books/linkers-and-loaders/linkers_and_loaders.pdf)
-  Large C++ programs are prone to develop hard-to-diagnose bugs due to unexpected things that happen at link time. (The best known are static constructors that run in an an or- der the programmer wasn’t expecting.)


### Linking and Loading
- Linkinng takes a name written by a pro- * grammer such as getline and binds it to ‘‘the location 612 bytes from * the beginning of the executable code in module iosys.’

- The program had to share the computer’s memory with the operating system and perhaps even with other programs, This means that the actual addresses at which the program would be running weren’t known until the operating system loaded the program into memory, deferring final address binding past link time to load time. Linkers and loaders now divided up the work, with linkers doing part of the address binding, assigning relative addresses within each program, and the loader doing a final relocation step to assign actual addresses.

- Program loading
    - Copy
    - Relocate
    - Symbol Resolution

- After the linker processes all of the regular input files, if any imported names remain undefined, it runs through the library or libraries and links in any of the files in the library that export one or more undefined names.

- Shared Libraries
    - Shared libraries complicate this task a little by moving some of the work from link time to load time. The linker identifies the shared libraries that resolve the undefined names in a linker run, but rather than linking any- thing into the program, the linker notes in the output file the names of the libraries in which the symbols were found, so that the shared library can be bound in when the program is loaded.

```asm
this snippet of x86 code that moves the contents of variable a to variable b using the eax register.

mov a,%eax
mov %eax,b

If a is defined in the same file at location 1234 hex and b is imported from somewhere else, the generated object code will be:

A1 34 12 00 00 mov a,%eax
A3 00 00 00 00 mov %eax,b

Each instruction contains a one-byte operation code followed by a four- byte address. The first instruction has a reference to 1234 (byte reversed, since the x86 uses a right to left byte order) and the second a reference to zero since the location of b is unknown.

Now assume that the linker links this code so that the section in which a is located is relocated by hex 10000 bytes, and b turns out to be at hex 9A12. The linker modifies the code to be:
A1 34 12 01 00 mov a,%eax
A3 12 9A 00 00 mov %eax,b
```

### Architectural Issues

### Object Files

An object file contains five kinds of information.

• Header information: overall information about the file, such as the size of the code, name of the source file it was translated from, and creation date.

• Object code: Binary instructions and data generated by a compiler or assembler.

• Relocation: A list of the places in the object code that have to be fixed up when the linker changes the addresses of the object code.

• Symbols: Global symbols defined in this module, symbols to be imported from other modules or defined by the linker.

• Debugging information: Other information about the object code not needed for linking but of use to a debugger. This includes source file and line number information, local symbols, descrip- tions of data structures used by the object code such as C structure definitions.
(Some object files contain even more than this, but these are plenty to keep us occupied in this chapter.)

### Storage allocation

### Symbol management

### Libraries

### Relocation

### Loading and overlays

### Shared libraries

### Dynamic Linking and Loading

### Advanced techniques